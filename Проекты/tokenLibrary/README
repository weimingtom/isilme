////////////////////////////////////////////////

		TokenLibrary                  //

///////////////////////////////////////////////

    Спасибо за использование библиотеке, хоть у вас и не было другого выбора!

    Содержание:

I. Описание функций и структуры
II. Подключение библиотеки
III. Пример кода
IV. То, что делать нежелательно
V. Приложение

I. Описание функций и структуры.

    Начнем, пожалуй, со структуры, так как все то, что делает библиотека основано именно на ней.
Встречайте:

struct XToken

{
	bool newLine;

	bool space;

	std::string text;

	bool hasNext;

};

Теперь, поля:   1) bool newLine. True - последующее отображение лексем должно начинаться с новой строки
				False - не должно.
		2) bool space. True - после данной лексемы необходимо поставить пробел.
				False - не нужно.
		3) std::string text - лексема.
		4) bool hasNext. True - задание еще не закончено и несобранные\невыбитые\несъеденные лексемы еще остались.
				False - еще осталась как минимум одна лексема.

Перейдем к функциям, которые будут делать всю пыльную работенку:

1) std::string getTopic( int number );

Функция, которая вернет в контейнере std::string тему заданий. int number - индекс темы от 0 до 7. При значении больше 7
функция вернет пустую строку. При значении меньше 0...вы будете приятно удивлены =).

2) std::string getDescription( int number );

Функция вернет сам текст задания какой ей вздумается. Хитрый метод случайного подбора был осуществлен с помощью функции rand();

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		! ! ! WARNING ! ! !

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Единственный аргумент этой функции должен совпадать с индексом темы задания. Будет печально, если тема будет на объявление
переменных, а текст задания на динамическую память.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		! ! ! WARNING ! ! !

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

3) TiXmlElement* getFirstToken( int number, XToken &other, TiXmlElement* tokens, std::string description );


Да, я полностью с вами согласен - это очень страшная функция! Но, не отчаивайтесь. С помощью этой функции мы сможем получить
первую правильную случайно сгенерированную лексему. Теперь, по порядку:

int number - очередной индекс нашей темы,который должен совпадать с предыдущими.

XToken &other - ссылка на экземпляр вышеописанной структуры. Не знаете, что такое ссылка??? Забыли, что такое экземпляр???
Не отчаивайтесь, горе-программист! Я вам все равно не скажу, так как вам это и не надо. Достаточно будет просто написать на 
этом месте переменную данного класса.

TiXmlElement* tokens - это самая жесть. Тут говорить нечего: если хотите узнать что это ( xDDD ) - гуглите, если нет - то
переходите к разделу 3 ( пример кода ).

std::string description - то, что вернула функция std::string getDescription( int number ); Но не стоит вызывать функцию, 
внутри самой функции. Нужно подставить именно то значение, которое вернула getDescription.

4) std::string generateInvalidToken();

Самая легкая функци в использовании из-за отсутствия аргументов. Возвращает одну "плохую" лексему.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		! ! ! WARNING ! ! !

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Может случиться так, что "плохая" лексема будет совпадать с нужной для поедания\собирания\уничтожения лексемой.
Так что стоит это каждый раз проверять!

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		! ! ! WARNING ! ! !

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

5) TiXmlElement* getNextToken( XToken &other, TiXmlElement* tokens );

Оба аргумента были описаны выше.


II. Подключение библиотеки.

Скопируйте Course.xml в корневой каталог проекта.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		! ! ! WARNING ! ! !

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Нажмите правой кнопкой на название проекта - свойства проекта - С\С++ - создание кода 
Поставьте бибилиотеку времени выполнения(run-time library) в режим Многопоточная отладка /MTd.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		! ! ! WARNING ! ! !

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Пожалуй, самый сложный этап =) Описание для VS2010, для 8-ой оно практически аналогичное
Открываем свой проект. Слева появляется меню. Правой кнопкой жмем на Решение <проект> - добавить - создать проект - 
- консольное приложение win32 - далее - статическая библиотека\убираем галочку с предкомпилированного заголовка - готово.
Копируем файлы tinystr.h и tinyxml.h в корнейвой кактог нового проекта.
Правой кнопкой жмем на заголовочные файлы нового проекта - добавить существующий элемент - добавляем tinystr.h и tinyxml.h
Жмем на главный проект правой кнопкой мыши - ссылки - добавить новую ссылку - выбираем новый проект - ок
Чтобы осознать все могущество библиотеке нужно всего добавить в заголовок #include "tinyxml.h"
Теперь жмем правой кнопкой мыши на основной проект - свойства конфигурации - каталоги VC++. В каталогах включения должен быть
указан путь к tinystr.h и tinyxml.h! В каталоги библиотек добавьте путь к tokenLibrary.lib!

III. Пример кода

XToken token;			 // объявляем экземпляр структуры
TiXmlDocument doc( "Course.xml" ); // обязательная строка
doc.LoadFile();				// обязательная строка
TiXmlElement* tkn = doc.FirstChildElement( "Root" ); // обязательная строка
std::string topic = getTopic( 4 ); // получаем тему топику
std::string description = getDescription( 4 );  // получаем само задание
tkn = getFirstToken( 4, token, tkn, description );  // token.text - нужная лексема
do
{
tkn = getNextToken( token, tkn );
} while ( token.hasNext == true );  // получение остальных лексем для выполнения задания
std::string invalidToken = generateInvalidToken();  // сгенерировать плохую лексему.

// Задание выполнено...теперь, нужно получить другое задание

tkn = doc.FirstChildElement( "Root" );
topic = getTopic( 4 );
description = getDescription( 4 );
tkn = getFirstToken( 4, token, tkn, description );
// ... и так далее...

ОБЯЗАТЕЛЬНО ОБЯЗАТЕЛЬНО ОБЯЗАТЕЛЬНО ОБЯЗАТЕЛЬНО ОБЯЗАТЕЛЬНО перед использованием getFirstToken используйте tkn = doc.FirstChildElement( "Root" );
, если не хотите, чтобы ваша программа вылетала.

IV. То, что делать нежелательно

Выумеете пользоваться отладкой с заходом? Отлично, только все равно посторонние файлы менять крайне нежелательно!

V. Приложение

Если компилятор ругается на то, что в каком-то каталоге отсутствует библиотека, то ее нужно уда скопировать.
Новый проект лучше называть tokenLibrary.
Не использовать функции библиотеки в пустом пространстве...Если вы пишите на HGE, то пишите код либо в RenderFunc, FrameFunc
или в функции main ( int WINAPI WinMain ), либо в своих функциях. Почему - не знаю даже я =)
Если компилятор ругается на std::string, попробуйте добавить #include <string> в заголовок. НЕ <string.h>, именно <string>
Всегда желательно проверять, а вдруг библиотека вас жестоко обманывает и возвращает пустые строки!